# 数据分析 - Pandas

## 简介

1. Pandas是基于NumPy构建的，让以NumPy为中心的应用变得更加简单。
2. Pandas是使数据分析工作变得更快、更简单的高级数据结构和操作工具。
3. 提供数据**按轴自动对齐**或数据对齐显示功能，可以防止许多由于数据未对齐以及数据源不同（索引方式不同）而导致的常见错误。
4. 处理缺失数据

> 两个主要数据结构：**Series**和**DataFrame**。

### Series数据结构

Series是一种类似于**一维数组**的对象，由**一组数据**以及一组与之相关的**数据标签**（索引）组成。

Series由两部分构成：索引放在左边，值放在右边。

如果没有为数据指定索引，Series也会自动创建一个0到N-1的整数型索引。

- Pandas最简单的Series
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"])
print(obj)

# Output:
# 0    287xxxx42
# 1    391xxxx91
# 2    281xxxx12
# 3    371xxxx31
# 4    261xxxx42
# dtype: object
```

- Pandas的Series的索引和值
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"])
obj_index = obj.index
obj_values = obj.values
print(obj_index)
print(obj_values)

# Output:
# RangeIndex(start=0, stop=5, step=1)
# ['287xxxx42' '391xxxx91' '281xxxx12' '371xxxx31' '261xxxx42']

# Explaination:
# obj.index内存储的就是Series中的索引
# obj.values内存储的就是Series的值。
```

- Pandas的Series的索引和值的输出
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"], index =["qq_name1","qq_name2","qq_name3","qq_name4","qq_name5"])
print(obj)

# Output:
# qq_name1    287xxxx42
# qq_name2    391xxxx91
# qq_name3    281xxxx12
# qq_name4    371xxxx31
# qq_name5    261xxxx42
# dtype: object
```

- Pandas中根据Series的索引输出值
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"], index =["qq_name1","qq_name2","qq_name3","qq_name4","qq_name5"])
print(obj)

# Output:
# qq_name1    287xxxx42
# qq_name2    391xxxx91
# qq_name3    281xxxx12
# qq_name4    371xxxx31
# qq_name5    261xxxx42
# dtype: object
```

```python
from pandas import Series
obj=Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"], index=["qq_name1","qq_name2","qq_name3","qq_name4","qq_name5"])
print(obj["qq_name1"])

# Output:
# 287xxxx42

# Explanation:
# 通过obj["qq_name1"]的引用方式来访问Series中"qq_name1"对应的值。
```

- Pandas中根据字典创建Series
```python
from pandas import Series
dicts = {"qq_name1":287xxxx42,"qq_name2":391xxxx91,"qq_name3":281xxxx12,"qq_name4":371xxxx31,"qq_name5":261xxxx42}
obj = Series(dicts)
print(obj)

# Output:
# qq_name1    287xxxx42
# qq_name2    391xxxx91
# qq_name3    281xxxx12
# qq_name4    371xxxx31
# qq_name5    261xxxx42
# dtype: object
```

### Series数据类型的运算

Series这种数据类型的最重要的一个功能是在进行算术运算时会**自动对齐**不同索引的数据。

- Pandas中根据Series数据类型的相加运算
```python
from pandas import Series
goods_in = Series({"苹果":30,"梨":25,"香蕉":20,"桃":21,"李子":15})
goods_other_in = Series({"苹果":10,"梨":20,"香蕉":15,"桃":10,"西瓜":50})
goods_kucun = goods_in + goods_other_in
print(goods_kucun)

# Output:
# 李子     NaN
# 桃     31.0
# 梨     45.0
# 苹果    40.0
# 西瓜     NaN
# 香蕉    35.0
# dtype: float64
```

> 如果两个Series相加，索引在两个Series中存在的话，就实现索引对应值的计算；如果其中一个Series中有的索引，另一个Series中没有，相加的结果中就会出现**NaN**（表示空值）这样的值。

- Pandas中根据Series索引赋值修改内容
```python
from pandas import Series
import numpy as np
goods = Series([30,25,20,21,np.nan],index=["苹果","梨","香蕉","桃","李子"])
goods["李子"] = 15
print(goods)

# Output:
# 苹果    30.0
# 梨     25.0
# 香蕉    20.0
# 桃     21.0
# 李子    15.0
# dtype: float64
```

### DataFrame数据结构

DataFrame是一个**表格型**的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型等）。

DataFrame既有**行索引**也有**列索引**，它可以被看作由Series组成的字典，只不过共用了索引。

- Pandas模块构建DataFrame
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints)
print(goods_in)

# Output:
#    字画名称  字画底价  字画拍卖加价
# 0  旭日东升  2860    1000
# 1  富水长流   498    2000
# 2  招财进宝  1068     500
# 3  鸿运当头   598    1500
```

- 利用Pandas模块的DataFrame指定列顺序
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns = ["字画名称","字画拍卖加价","字画底价"])
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价
# 0  旭日东升    1000  2860
# 1  富水长流    2000   498
# 2  招财进宝     500  1068
# 3  鸿运当头    1500   598
```

DataFrame最终是按照columns指定的顺序排列的。如果传入的列名在数据中是无法找到的，就会产生NaN值。

- 利用Pandas模块的DataFrame指定列空缺
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns = ["字画名称","字画拍卖加价","字画底价","字画所属人"])
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价 字画所属人
# 0  旭日东升    1000  2860   NaN
# 1  富水长流    2000   498   NaN
# 2  招财进宝     500  1068   NaN
# 3  鸿运当头    1500   598   NaN
```

- 利用Pandas模块的DataFrame通过字典标记的方式获取Series结构列数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index = ["第一幅","第二幅","第三幅","第四幅"])
paints_price = goods_in["字画底价"]
print(paints_price)

# Output:
# 第一幅    2860
# 第二幅     498
# 第三幅    1068
# 第四幅     598
# Name: 字画底价, dtype: int64

# Explanation:
# 代码中定义了字画的DataFrame之后，直接通过goods_in["字画底价"]来访问“字画底价”这个维度的数据，获取的是一个Series结构的数据。
```

- 利用Pandas模块的DataFrame通过位置获取Series结构行数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index = ["第一幅","第二幅","第三幅","第四幅"])
paints_three = goods_in.loc["第三幅"]
print(paints_three)

# Output:
# 字画名称      招财进宝
# 字画底价      1068
# 字画拍卖加价     500
# ame: 第三幅, dtype: object
```

> loc就是位置的关键词

-利用Pandas模块的DataFrame通过位置结合切片获取数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=["第一幅","第二幅","第三幅","第四幅"])
paints_three = goods_in.loc["第三幅":"第四幅","字画名称":"字画底价"]
print(paints_three)
print("---------------------------------------------------")
paints_four = goods_in.loc[["第三幅","第四幅"],["字画名称","字画底价"]]
print(paints_four)

# Output:
#      字画名称  字画底价
# 第三幅  招财进宝  1068
# 第四幅  鸿运当头   598
# ---------------------------------------------------
#      字画名称  字画底价
# 第三幅  招财进宝  1068
# 第四幅  鸿运当头   598
```

- 利用Pandas模块的DataFrame通过位置结合布尔型数组获取数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=["第一幅","第二幅","第三幅","第四幅"])
paints_three = goods_in.loc[goods_in["字画底价"]>500,:]
print(paints_three)
print("------------------------------------------")
paints_four = goods_in.loc[(goods_in["字画底价"]>500)&(goods_in["字画拍卖加价"]>1000),:]
print(paints_four)

# Output:
#      字画名称  字画底价  字画拍卖加价
# 第一幅  旭日东升  2860    1000
# 第三幅  招财进宝  1068     500
# 第四幅  鸿运当头   598    1500
# ------------------------------------------
#      字画名称  字画底价  字画拍卖加价
# 第四幅  鸿运当头   598    1500
```

### DataFrame数据的修改

DataFrame数据结构内的列可以通过赋值的方式进行修改。

- 利用Pandas模块的DataFrame修改列数据为相同值
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns=["字画名称","字画拍卖加价","字画底价","字画所属人"])
goods_in["字画所属人"] = "张三"
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价 字画所属人
# 0  旭日东升    1000  2860    张三
# 1  富水长流    2000   498    张三
# 2  招财进宝     500  1068    张三
# 3  鸿运当头    1500   598    张三

# Explanation:
# 代码中定义DataFrame时columns列表中有“字画所属人”，其实是没有这个数据的。最开始是空数据，可通过goods_in["字画所属人"]="张三"赋值语句为“字画所属人”的整列进行赋值。
```

也可以通过列表类型为“字画所属人”的每一行数据赋不同的值

- 利用Pandas模块的DataFrame修改列数据为不同值
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns=["字画名称","字画拍卖加价","字画底价","字画所属人"])
goods_in["字画所属人"] = ["张三","李四","王五","赵六"]
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价 字画所属人
# 0  旭日东升    1000  2860    张三
# 1  富水长流    2000   498    李四
# 2  招财进宝     500  1068    王五
# 3  鸿运当头    1500   598    赵六
```

关键字del用于删除列，可通过del　DataFrame名["列名"]格式来进行删除操作

- 利用Pandas模块的DataFrame删除列数据的操作
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500], "字画所属人":["张三","李四","王五","赵六"]}
goods_in = DataFrame(paints, columns = ["字画名称","字画拍卖加价","字画底价","字画所属人"])
del goods_in["字画所属人"]
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价
# 0  旭日东升    1000  2860
# 1  富水长流    2000   498
# 2  招财进宝     500  1068
# 3  鸿运当头    1500   598
```

如果在创建DataFrame的时候传入的字典参数是嵌套字典，也就是“字典的字典”，则会被解释为外层字典的键作为列，内层字典的键作为行索引

代码中字典定义的是一个嵌套字典，内层字典的键都是等长的，而且会被合并、排序，从而形成最终的索引。

- 利用Pandas模块的嵌套字典形成DataFrame数据结构
```python
from pandas import DataFrame
paints = {"字画名称":{"第一幅":"旭日东升","第二幅":"富水长流","第三幅":"招财进宝","第四幅":"鸿运当头"},"字画底价":{"第一幅":2860,"第二幅":498,"第三幅":1068,"第四幅":598},"字画拍卖加价":{"第一幅":1000,"第二幅":2000,"第三幅":500,"第四幅":1500}}
goods_in = DataFrame(paints, columns=["字画名称","字画拍卖加价","字画底价"])
print(goods_in)

# Output:
#      字画名称  字画拍卖加价  字画底价
# 第一幅  旭日东升    1000  2860
# 第二幅  富水长流    2000   498
# 第三幅  招财进宝     500  1068
# 第四幅  鸿运当头    1500   598
```

### 　DataFrame中的索引对象

注意: 索引对象是**不能被修改**的

其实不可修改性也是很重要的，这样可以保证索引对象在多个数据结构之间安全共享。

- Pandas模块中DataFrame索引对象的不可修改性
```python
from pandas import DataFrame
paints = {"字画名称":{"第一幅":"旭日东升","第二幅":"富水长流","第三幅":"招财进宝","第四幅":"鸿运当头"},"字画底价":{"第一幅":2860,"第二幅":498,"第三幅":1068,"第四幅":598},"字画拍卖加价":{"第一幅":1000,"第二幅":2000,"第三幅":500,"第四幅":1500}}
goods_in = DataFrame(paints)
goods_in.index[1] = "字画拍卖底价"
print(goods_in.index)

# Output:
# Traceback (most recent call last):
#   File "c:\Users\CHIN WEI YEW\Documents\GitHub\MachineLearning\Testing.py", line 4, in <module>
#     goods_in.index[1]="字画拍卖底价"
#     ~~~~~~~~~~~~~~^^^
#   File "C:\Users\CHIN WEI YEW\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\indexes\base.py", line 5347, in __setitem__
#     raise TypeError("Index does not support mutable operations")
# TypeError: Index does not support mutable operations
```

### 层次化索引

层次化索引（hierarchical indexing）是Pandas的一个重要特点，使用户能在一个轴上拥有多个（两个以上）索引级别。

抽象点儿说，它使用户能以低维度形式处理高维度数据。比如创建一个Series，并用一个由多个列表或数组组成的列表作为索引。

- Pandas模块中的层次化索引
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
print(goods_in)

# Output:
#            字画名称  字画底价  字画拍卖加价
# 第一拍卖现场 第一幅  旭日东升  2860    1000
#       第二幅  富水长流   498    2000
# 第二拍卖现场 第一幅  招财进宝  1068     500
#       第二幅  鸿运当头   598    1500

# Explanation:
# "第一拍卖现场" "第二拍卖现场"是第一级索引值，"第一幅" "第二幅"是第二级索引值。后面的数据就是"第一幅"或"第二幅"对应的"字画名称" "字画底价"及"字画拍卖加价"的信息内容
# 其实，这就是带有MultiIndex索引的Series的格式化输出形式。
```

- Pandas模块中的层次化索引结构
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints,index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_in_indexes = goods_in.index
print(goods_in_indexes)

# Output:
# MultiIndex([('第一拍卖现场', '第一幅'),
#             ('第一拍卖现场', '第二幅'),
#             ('第二拍卖现场', '第一幅'),
#             ('第二拍卖现场', '第二幅')],
#            )

# Explanation:
# 从运行结果上看，这种层次化的索引会将第一级索引和第二级索引以元素的形式一一对应起来，整个DataFrame数据结构的索引就保存在一一对应关系元组组成的列表中。
```

- Pandas模块中层次化索引结构的行选取
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_in_second = goods_in.loc["第二拍卖现场"]
print(goods_in_second)
print("--------------------------------------")
goods_in_second_one=goods_in.loc["第二拍卖现场","第一幅"]
print(goods_in_second_one)

# Output:
#      字画名称  字画底价  字画拍卖加价
# 第一幅  招财进宝  1068     500
# 第二幅  鸿运当头   598    1500
# --------------------------------------
# 字画名称      招财进宝
# 字画底价      1068
# 字画拍卖加价     500
# Name: (第二拍卖现场, 第一幅), dtype: object

# Explanation:
# 1. 代码中调用了两次goods_in.loc()方法，第一次获取第一级索引为"第二拍卖现场"，直接在方括号中调用列索引即可；
# 2. 第二次获取第一级索引中的第二级索引，方括号中引用的两个不同级索引用逗号隔开。
# 3. 虚线上面输出"第二拍卖现场"索引级别下的所有数据，虚线下面输出“第二拍卖现场"中"第一幅”索引下的所有数据，在最后一行输出"Name"（后面有标注，显示相应索引后的具体数据）。
```

层次化索引在数据重塑和基于分组的操作中有着重要的作用。比如说，数据可以通过unstack()方法被重新安排到一个DataFrame中

- DataFrame数据结构的unstack()方法
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_stack = goods_in.unstack()
print(goods_stack)

# Output:
#         字画名称        字画底价      字画拍卖加价      
#          第一幅   第二幅   第一幅  第二幅    第一幅   第二幅
# 第一拍卖现场  旭日东升  富水长流  2860  498   1000  2000
# 第二拍卖现场  招财进宝  鸿运当头  1068  598    500  1500

# Explanation:
# 代码中调用了unstack()方法，第一次获取第一级索引为“第二拍卖现场”，直接在方括号中调用列索引即可。
# 使用unstack()方法，DataFrame数据结构的第二层列索引被转变成行索引。
```

与unstack()相反的操作（也称为逆运算）就是stack()

- DataFrame数据结构的stack()方法
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_stack = goods_in.unstack().stack()
print(goods_stack)

# Output:
#             字画名称  字画底价  字画拍卖加价
# 第一拍卖现场 第一幅  旭日东升  2860    1000
#        第二幅  富水长流   498    2000
# 第二拍卖现场 第一幅  招财进宝  1068     500
#        第二幅  鸿运当头   598    1500

# Explanation:
# 代码中DataFrame数据结构的字画拍卖数据被用unstack()方法把列索引变成了行索引，而调用stack()后，又把行索引变成了列索引。
```