# 数据分析 - Pandas

## Pandas数据结构的介绍

1. Pandas是基于NumPy构建的，让以NumPy为中心的应用变得更加简单。
2. Pandas是使数据分析工作变得更快、更简单的高级数据结构和操作工具。
3. 提供数据**按轴自动对齐**或数据对齐显示功能，可以防止许多由于数据未对齐以及数据源不同（索引方式不同）而导致的常见错误。
4. 处理缺失数据

> 两个主要数据结构：**Series**和**DataFrame**。

### Series数据结构

Series是一种类似于**一维数组**的对象，由**一组数据**以及一组与之相关的**数据标签**（索引）组成。

Series由两部分构成：索引放在左边，值放在右边。

如果没有为数据指定索引，Series也会自动创建一个0到N-1的整数型索引。

- Pandas最简单的Series
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"])
print(obj)

# Output:
# 0    287xxxx42
# 1    391xxxx91
# 2    281xxxx12
# 3    371xxxx31
# 4    261xxxx42
# dtype: object
```

- Pandas的Series的索引和值
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"])
obj_index = obj.index
obj_values = obj.values
print(obj_index)
print(obj_values)

# Output:
# RangeIndex(start=0, stop=5, step=1)
# ['287xxxx42' '391xxxx91' '281xxxx12' '371xxxx31' '261xxxx42']

# Explaination:
# obj.index内存储的就是Series中的索引
# obj.values内存储的就是Series的值。
```

- Pandas的Series的索引和值的输出
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"], index =["qq_name1","qq_name2","qq_name3","qq_name4","qq_name5"])
print(obj)

# Output:
# qq_name1    287xxxx42
# qq_name2    391xxxx91
# qq_name3    281xxxx12
# qq_name4    371xxxx31
# qq_name5    261xxxx42
# dtype: object
```

- Pandas中根据Series的索引输出值
```python
from pandas import Series
obj = Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"], index =["qq_name1","qq_name2","qq_name3","qq_name4","qq_name5"])
print(obj)

# Output:
# qq_name1    287xxxx42
# qq_name2    391xxxx91
# qq_name3    281xxxx12
# qq_name4    371xxxx31
# qq_name5    261xxxx42
# dtype: object
```

```python
from pandas import Series
obj=Series(["287xxxx42","391xxxx91","281xxxx12","371xxxx31","261xxxx42"], index=["qq_name1","qq_name2","qq_name3","qq_name4","qq_name5"])
print(obj["qq_name1"])

# Output:
# 287xxxx42

# Explanation:
# 通过obj["qq_name1"]的引用方式来访问Series中"qq_name1"对应的值。
```

- Pandas中根据字典创建Series
```python
from pandas import Series
dicts = {"qq_name1":287xxxx42,"qq_name2":391xxxx91,"qq_name3":281xxxx12,"qq_name4":371xxxx31,"qq_name5":261xxxx42}
obj = Series(dicts)
print(obj)

# Output:
# qq_name1    287xxxx42
# qq_name2    391xxxx91
# qq_name3    281xxxx12
# qq_name4    371xxxx31
# qq_name5    261xxxx42
# dtype: object
```

### Series数据类型的运算

Series这种数据类型的最重要的一个功能是在进行算术运算时会**自动对齐**不同索引的数据。

- Pandas中根据Series数据类型的相加运算
```python
from pandas import Series
goods_in = Series({"苹果":30,"梨":25,"香蕉":20,"桃":21,"李子":15})
goods_other_in = Series({"苹果":10,"梨":20,"香蕉":15,"桃":10,"西瓜":50})
goods_kucun = goods_in + goods_other_in
print(goods_kucun)

# Output:
# 李子     NaN
# 桃     31.0
# 梨     45.0
# 苹果    40.0
# 西瓜     NaN
# 香蕉    35.0
# dtype: float64
```

> 如果两个Series相加，索引在两个Series中存在的话，就实现索引对应值的计算；如果其中一个Series中有的索引，另一个Series中没有，相加的结果中就会出现**NaN**（表示空值）这样的值。

- Pandas中根据Series索引赋值修改内容
```python
from pandas import Series
import numpy as np
goods = Series([30,25,20,21,np.nan],index=["苹果","梨","香蕉","桃","李子"])
goods["李子"] = 15
print(goods)

# Output:
# 苹果    30.0
# 梨     25.0
# 香蕉    20.0
# 桃     21.0
# 李子    15.0
# dtype: float64
```

### DataFrame数据结构

DataFrame是一个**表格型**的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型等）。

DataFrame既有**行索引**也有**列索引**，它可以被看作由Series组成的字典，只不过共用了索引。

- Pandas模块构建DataFrame
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints)
print(goods_in)

# Output:
#    字画名称  字画底价  字画拍卖加价
# 0  旭日东升  2860    1000
# 1  富水长流   498    2000
# 2  招财进宝  1068     500
# 3  鸿运当头   598    1500
```

- 利用Pandas模块的DataFrame指定列顺序
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns = ["字画名称","字画拍卖加价","字画底价"])
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价
# 0  旭日东升    1000  2860
# 1  富水长流    2000   498
# 2  招财进宝     500  1068
# 3  鸿运当头    1500   598
```

DataFrame最终是按照columns指定的顺序排列的。如果传入的列名在数据中是无法找到的，就会产生NaN值。

- 利用Pandas模块的DataFrame指定列空缺
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns = ["字画名称","字画拍卖加价","字画底价","字画所属人"])
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价 字画所属人
# 0  旭日东升    1000  2860   NaN
# 1  富水长流    2000   498   NaN
# 2  招财进宝     500  1068   NaN
# 3  鸿运当头    1500   598   NaN
```

- 利用Pandas模块的DataFrame通过字典标记的方式获取Series结构列数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index = ["第一幅","第二幅","第三幅","第四幅"])
paints_price = goods_in["字画底价"]
print(paints_price)

# Output:
# 第一幅    2860
# 第二幅     498
# 第三幅    1068
# 第四幅     598
# Name: 字画底价, dtype: int64

# Explanation:
# 代码中定义了字画的DataFrame之后，直接通过goods_in["字画底价"]来访问“字画底价”这个维度的数据，获取的是一个Series结构的数据。
```

- 利用Pandas模块的DataFrame通过位置获取Series结构行数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index = ["第一幅","第二幅","第三幅","第四幅"])
paints_three = goods_in.loc["第三幅"]
print(paints_three)

# Output:
# 字画名称      招财进宝
# 字画底价      1068
# 字画拍卖加价     500
# ame: 第三幅, dtype: object
```

> loc就是位置的关键词

-利用Pandas模块的DataFrame通过位置结合切片获取数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=["第一幅","第二幅","第三幅","第四幅"])
paints_three = goods_in.loc["第三幅":"第四幅","字画名称":"字画底价"]
print(paints_three)
print("---------------------------------------------------")
paints_four = goods_in.loc[["第三幅","第四幅"],["字画名称","字画底价"]]
print(paints_four)

# Output:
#      字画名称  字画底价
# 第三幅  招财进宝  1068
# 第四幅  鸿运当头   598
# ---------------------------------------------------
#      字画名称  字画底价
# 第三幅  招财进宝  1068
# 第四幅  鸿运当头   598
```

- 利用Pandas模块的DataFrame通过位置结合布尔型数组获取数据
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=["第一幅","第二幅","第三幅","第四幅"])
paints_three = goods_in.loc[goods_in["字画底价"]>500,:]
print(paints_three)
print("------------------------------------------")
paints_four = goods_in.loc[(goods_in["字画底价"]>500)&(goods_in["字画拍卖加价"]>1000),:]
print(paints_four)

# Output:
#      字画名称  字画底价  字画拍卖加价
# 第一幅  旭日东升  2860    1000
# 第三幅  招财进宝  1068     500
# 第四幅  鸿运当头   598    1500
# ------------------------------------------
#      字画名称  字画底价  字画拍卖加价
# 第四幅  鸿运当头   598    1500
```

### DataFrame数据的修改

DataFrame数据结构内的列可以通过赋值的方式进行修改。

- 利用Pandas模块的DataFrame修改列数据为相同值
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns=["字画名称","字画拍卖加价","字画底价","字画所属人"])
goods_in["字画所属人"] = "张三"
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价 字画所属人
# 0  旭日东升    1000  2860    张三
# 1  富水长流    2000   498    张三
# 2  招财进宝     500  1068    张三
# 3  鸿运当头    1500   598    张三

# Explanation:
# 代码中定义DataFrame时columns列表中有“字画所属人”，其实是没有这个数据的。最开始是空数据，可通过goods_in["字画所属人"]="张三"赋值语句为“字画所属人”的整列进行赋值。
```

也可以通过列表类型为“字画所属人”的每一行数据赋不同的值

- 利用Pandas模块的DataFrame修改列数据为不同值
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, columns=["字画名称","字画拍卖加价","字画底价","字画所属人"])
goods_in["字画所属人"] = ["张三","李四","王五","赵六"]
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价 字画所属人
# 0  旭日东升    1000  2860    张三
# 1  富水长流    2000   498    李四
# 2  招财进宝     500  1068    王五
# 3  鸿运当头    1500   598    赵六
```

关键字del用于删除列，可通过del　DataFrame名["列名"]格式来进行删除操作

- 利用Pandas模块的DataFrame删除列数据的操作
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500], "字画所属人":["张三","李四","王五","赵六"]}
goods_in = DataFrame(paints, columns = ["字画名称","字画拍卖加价","字画底价","字画所属人"])
del goods_in["字画所属人"]
print(goods_in)

# Output:
#    字画名称  字画拍卖加价  字画底价
# 0  旭日东升    1000  2860
# 1  富水长流    2000   498
# 2  招财进宝     500  1068
# 3  鸿运当头    1500   598
```

如果在创建DataFrame的时候传入的字典参数是嵌套字典，也就是“字典的字典”，则会被解释为外层字典的键作为列，内层字典的键作为行索引

代码中字典定义的是一个嵌套字典，内层字典的键都是等长的，而且会被合并、排序，从而形成最终的索引。

- 利用Pandas模块的嵌套字典形成DataFrame数据结构
```python
from pandas import DataFrame
paints = {"字画名称":{"第一幅":"旭日东升","第二幅":"富水长流","第三幅":"招财进宝","第四幅":"鸿运当头"},"字画底价":{"第一幅":2860,"第二幅":498,"第三幅":1068,"第四幅":598},"字画拍卖加价":{"第一幅":1000,"第二幅":2000,"第三幅":500,"第四幅":1500}}
goods_in = DataFrame(paints, columns=["字画名称","字画拍卖加价","字画底价"])
print(goods_in)

# Output:
#      字画名称  字画拍卖加价  字画底价
# 第一幅  旭日东升    1000  2860
# 第二幅  富水长流    2000   498
# 第三幅  招财进宝     500  1068
# 第四幅  鸿运当头    1500   598
```

### DataFrame中的索引对象

注意: 索引对象是**不能被修改**的

其实不可修改性也是很重要的，这样可以保证索引对象在多个数据结构之间安全共享。

- Pandas模块中DataFrame索引对象的不可修改性
```python
from pandas import DataFrame
paints = {"字画名称":{"第一幅":"旭日东升","第二幅":"富水长流","第三幅":"招财进宝","第四幅":"鸿运当头"},"字画底价":{"第一幅":2860,"第二幅":498,"第三幅":1068,"第四幅":598},"字画拍卖加价":{"第一幅":1000,"第二幅":2000,"第三幅":500,"第四幅":1500}}
goods_in = DataFrame(paints)
goods_in.index[1] = "字画拍卖底价"
print(goods_in.index)

# Output:
# Traceback (most recent call last):
#   File "c:\Users\CHIN WEI YEW\Documents\GitHub\MachineLearning\Testing.py", line 4, in <module>
#     goods_in.index[1]="字画拍卖底价"
#     ~~~~~~~~~~~~~~^^^
#   File "C:\Users\CHIN WEI YEW\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\indexes\base.py", line 5347, in __setitem__
#     raise TypeError("Index does not support mutable operations")
# TypeError: Index does not support mutable operations
```

### 层次化索引

层次化索引（hierarchical indexing）是Pandas的一个重要特点，使用户能在一个轴上拥有多个（两个以上）索引级别。

抽象点儿说，它使用户能以低维度形式处理高维度数据。比如创建一个Series，并用一个由多个列表或数组组成的列表作为索引。

- Pandas模块中的层次化索引
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
print(goods_in)

# Output:
#            字画名称  字画底价  字画拍卖加价
# 第一拍卖现场 第一幅  旭日东升  2860    1000
#       第二幅  富水长流   498    2000
# 第二拍卖现场 第一幅  招财进宝  1068     500
#       第二幅  鸿运当头   598    1500

# Explanation:
# "第一拍卖现场" "第二拍卖现场"是第一级索引值，"第一幅" "第二幅"是第二级索引值。后面的数据就是"第一幅"或"第二幅"对应的"字画名称" "字画底价"及"字画拍卖加价"的信息内容
# 其实，这就是带有MultiIndex索引的Series的格式化输出形式。
```

- Pandas模块中的层次化索引结构
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints,index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_in_indexes = goods_in.index
print(goods_in_indexes)

# Output:
# MultiIndex([('第一拍卖现场', '第一幅'),
#             ('第一拍卖现场', '第二幅'),
#             ('第二拍卖现场', '第一幅'),
#             ('第二拍卖现场', '第二幅')],
#            )

# Explanation:
# 从运行结果上看，这种层次化的索引会将第一级索引和第二级索引以元素的形式一一对应起来，整个DataFrame数据结构的索引就保存在一一对应关系元组组成的列表中。
```

- Pandas模块中层次化索引结构的行选取
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"],"字画底价":[2860,498,1068,598],"字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_in_second = goods_in.loc["第二拍卖现场"]
print(goods_in_second)
print("--------------------------------------")
goods_in_second_one=goods_in.loc["第二拍卖现场","第一幅"]
print(goods_in_second_one)

# Output:
#      字画名称  字画底价  字画拍卖加价
# 第一幅  招财进宝  1068     500
# 第二幅  鸿运当头   598    1500
# --------------------------------------
# 字画名称      招财进宝
# 字画底价      1068
# 字画拍卖加价     500
# Name: (第二拍卖现场, 第一幅), dtype: object

# Explanation:
# 1. 代码中调用了两次goods_in.loc()方法，第一次获取第一级索引为"第二拍卖现场"，直接在方括号中调用列索引即可；
# 2. 第二次获取第一级索引中的第二级索引，方括号中引用的两个不同级索引用逗号隔开。
# 3. 虚线上面输出"第二拍卖现场"索引级别下的所有数据，虚线下面输出“第二拍卖现场"中"第一幅”索引下的所有数据，在最后一行输出"Name"（后面有标注，显示相应索引后的具体数据）。
```

层次化索引在数据重塑和基于分组的操作中有着重要的作用。比如说，数据可以通过unstack()方法被重新安排到一个DataFrame中

- DataFrame数据结构的unstack()方法
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_stack = goods_in.unstack()
print(goods_stack)

# Output:
#         字画名称        字画底价      字画拍卖加价          
#          第一幅   第二幅   第一幅  第二幅    第一幅   第二幅
# 第一拍卖现场  旭日东升  富水长流  2860  498   1000  2000    
# 第二拍卖现场  招财进宝  鸿运当头  1068  598    500  1500

# Explanation:
# 代码中调用了unstack()方法，第一次获取第一级索引为“第二拍卖现场”，直接在方括号中调用列索引即可。
# 使用unstack()方法，DataFrame数据结构的第二层列索引被转变成行索引。
```

与unstack()相反的操作（也称为逆运算）就是stack()

- DataFrame数据结构的stack()方法
```python
from pandas import DataFrame
paints = {"字画名称":["旭日东升","富水长流","招财进宝","鸿运当头"], "字画底价":[2860,498,1068,598], "字画拍卖加价":[1000,2000,500,1500]}
goods_in = DataFrame(paints, index=[["第一拍卖现场","第一拍卖现场","第二拍卖现场","第二拍卖现场"],["第一幅","第二幅","第一幅","第二幅"]])
goods_stack = goods_in.unstack().stack()
print(goods_stack)

# Output:
#             字画名称  字画底价  字画拍卖加价
# 第一拍卖现场 第一幅  旭日东升  2860    1000
#        第二幅  富水长流   498    2000
# 第二拍卖现场 第一幅  招财进宝  1068     500
#        第二幅  鸿运当头   598    1500

# Explanation:
# 代码中DataFrame数据结构的字画拍卖数据被用unstack()方法把列索引变成了行索引，而调用stack()后，又把行索引变成了列索引。
```

## Pandas数据结构中的基本数据操作

### 重新索引

- 利用Pandas模块中的reindex()修改索引的显示顺序
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index = ["第一辆车","第二辆车","第三辆车"])
print(goods_in)
other_goods = goods_in.reindex(["第三辆车","第二辆车","第一辆车"])
print(other_goods)

# Output:
#          车名   最低报价   最高报价
# 第一辆车  奥迪Q5L  38.78  49.80
# 第二辆车   哈弗H6   9.80  14.10
# 第三辆车  奔驰GLC  39.48  58.78
#          车名   最低报价   最高报价
# 第三辆车  奔驰GLC  39.48  58.78
# 第二辆车   哈弗H6   9.80  14.10
# 第一辆车  奥迪Q5L  38.78  49.80
```

- 在Pandas模块的reindex()中添加了无此索引的项
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index=["第一辆车","第二辆车","第三辆车"])
print(goods_in)
other_goods=goods_in.reindex(["第三辆车","第二辆车","第一辆车","第四辆车"])
print(other_goods)

# Output:
#          车名   最低报价   最高报价
# 第一辆车  奥迪Q5L  38.78  49.80
# 第二辆车   哈弗H6   9.80  14.10
# 第三辆车  奔驰GLC  39.48  58.78
#          车名   最低报价   最高报价
# 第三辆车  奔驰GLC  39.48  58.78
# 第二辆车   哈弗H6   9.80  14.10
# 第一辆车  奥迪Q5L  38.78  49.80
# 第四辆车    NaN    NaN    NaN

# Explanation:
# 对重新索引前后的代码运行结果进行对比可发现，多了一个"第四辆车"的索引，且因为没有对应的数据，显示的数据值均为NaN。
```

- 在Pandas模块的reindex()中用fill_value设置无此索引的项
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index=["第一辆车","第二辆车","第三辆车"])
print(goods_in)
other_goods = goods_in.reindex(["第三辆车","第二辆车","第一辆车","第四辆车"], fill_value = 7.90)
print(other_goods)

# Output:
#          车名   最低报价   最高报价
# 第一辆车  奥迪Q5L  38.78  49.80
# 第二辆车   哈弗H6   9.80  14.10
# 第三辆车  奔驰GLC  39.48  58.78
#          车名   最低报价   最高报价
# 第三辆车  奔驰GLC  39.48  58.78
# 第二辆车   哈弗H6   9.80  14.10
# 第一辆车  奥迪Q5L  38.78  49.80
# 第四辆车    7.9   7.90   7.90

# Explanation:
# 代码中调用reindex()方法时，添加了一个原来索引对象中没有的项"第四辆车"，又通过属性fill_value=7.90设置新加入的索引对象对应的数据值均为7.90。
```

从运行结果上看，显然填充fill_value对于车名来说是不科学的。因此，可以用前填充和后填充的方式。这样就引入了method属性，设置method的属性值为“ffill”就可以实现前填充，也就是根据前一个数据的值进行数据的填充。

注意，reindex()中的参数，也就是列表的值一定是一个数值序列。如果不是一个数值序列，而是"第一辆车", "第二辆车", "第三辆车"等文本就会提示错误。

- 在Pandas模块的reindex()中用method前填充设置无此索引的项
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index = [1,2,3])
print(goods_in)
other_goods = goods_in.reindex([1,2,3,4], method="ffill")
print(other_goods)

# Output:
#       车名   最低报价   最高报价
# 1  奥迪Q5L  38.78  49.80
# 2   哈弗H6   9.80  14.10
# 3  奔驰GLC  39.48  58.78
#       车名   最低报价   最高报价
# 1  奥迪Q5L  38.78  49.80
# 2   哈弗H6   9.80  14.10
# 3  奔驰GLC  39.48  58.78
# 4  奔驰GLC  39.48  58.78
```

- reindex()属性method的参数
<table>
    <tr>
        <th>参数</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>ffill或pad</td>
        <td>前向填充（或搬运）值</td>
    </tr>
    <tr>
        <td>bfill或backfill</td>
        <td>后向填充（或搬运）值</td>
    </tr>
</table>

对于DataFrame，reindex()不但可以修改行索引，也可以修改列索引，通过columns关键字可以实现重新索引列

- 在Pandas模块的reindex()中用columns关键字重新索引列
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
print(goods_in)
other_goods=goods_in.reindex(columns = ["车名","最高报价","最低报价","标配价"])
print(other_goods)

# Output:
#       车名   最低报价   最高报价
# 1  奥迪Q5L  38.78  49.80
# 2   哈弗H6   9.80  14.10
# 3  奔驰GLC  39.48  58.78
#       车名   最高报价   最低报价  标配价
# 1  奥迪Q5L  49.80  38.78  NaN
# 2   哈弗H6  14.10   9.80  NaN
# 3  奔驰GLC  58.78  39.48  NaN

# Explanation:
# 重新索引后不但列显示的顺序调整了，同时还多了一列“标配价”，只不过没有数据值，只能显示NaN。
```

> method的填充方式是按行填充，不能按列填充。

- reindex()的参数及说明
<table>
    <tr>
        <th>参数</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>index</td>
        <td>用作索引的新序列，既可以是index实例，也可以是序列型结构的Python列表、元组等</td>
    </tr>
    <tr>
        <td>method</td>
        <td>插值（填充）方式</td>
    </tr>
    <tr>
        <td>fill_value</td>
        <td>在重新索引的过程中,需要引入缺失值时使用的替代值</td>
    </tr>
    <tr>
        <td>limit</td>
        <td>前向或后向填充时的最大填充量</td>
    </tr>
    <tr>
        <td>level</td>
        <td>在MultiIndex的指定级别上匹配简单索引，否则选取其子集</td>
    </tr>
    <tr>
        <td>copy</td>
        <td>默认为True，此时无论如何都复制；如果为False，则新旧值相等就不复制</td>
    </tr>
</table>

### 删除指定轴上的项

删除某条轴上的一个或多个项可以使用drop()方法，有一个索引数组或列表即可。drop()方法需要执行一些数据整理和集合逻辑处理工作，会返回一个在指定轴上删除了指定值的新对象

- 利用Pandas模块的drop()方法删除*行数据*
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in =  goods_in.drop(2)
print(goods_in)

# Output:
#       车名   最低报价   最高报价
# 1  奥迪Q5L  38.78  49.80
# 3  奔驰GLC  39.48  58.78
```

- 利用Pandas模块的drop()方法删除*列数据*
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[38.78,9.80,39.48], "最高报价":[49.80,14.10,58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in =  goods_in.drop(["最高报价", "最低报价"], axis = 1)
print(goods_in)

# Output:
#       车名
# 1  奥迪Q5L
# 2   哈弗H6
# 3  奔驰GLC
```

### 算术运算和数据对齐

- 两家幼儿园DataFrame 数据的加法合并
```python
from pandas import DataFrame
kindergarten1 = {"小朋友数目":{"1班":32,"2班":20},"小朋友睡床":{"1班":40,"2班":30},"上课教室":{"1班":3,"2班":2}}
kindergarten2 = {"小朋友数目":{"1班":10,"2班":21,"3班":15},"小朋友睡床":{"1班":11,"2班":21,"3班":16},"上课教室":{"1班":1,"2班":2,"3班":2}}
kindergarten_dataframe1 = DataFrame(kindergarten1)
kindergarten_dataframe2 = DataFrame(kindergarten2)
kindergarten_all = kindergarten_dataframe1 + kindergarten_dataframe2
print(kindergarten_all)

# Output:
#     小朋友数目  小朋友睡床  上课教室
# 1班   42.0   51.0   4.0
# 2班   41.0   51.0   4.0
# 3班    NaN    NaN   NaN

# Explanation:
# 一家幼儿园有索引项"3班"，另一家幼儿园没有索引项"3班"，在进行相加运算时数据就会显示NaN。
```

- 使用add()方法实现两家幼儿园DataFrame 数据的合并
```python
from pandas import DataFrame
kindergarten1 = {"小朋友数目":{"1班":32,"2班":20},"小朋友睡床":{"1班":40,"2班":30},"上课教室":{"1班":3,"2班":2}}
kindergarten2 = {"小朋友数目":{"1班":10,"2班":21,"3班":15},"小朋友睡床":{"1班":11,"2班":21,"3班":16},"上课教室":{"1班":1,"2班":2,"3班":2}}
kindergarten_dataframe1 = DataFrame(kindergarten1)
kindergarten_dataframe2 = DataFrame(kindergarten2)
kindergarten_all = kindergarten_dataframe1.add(kindergarten_dataframe2, fill_value = 0)
print(kindergarten_all)

# Output:
#     小朋友数目  小朋友睡床  上课教室
# 1班   42.0   51.0   4.0
# 2班   41.0   51.0   4.0
# 3班   15.0   16.0   2.0

# Explanation:
# add()方法中传入了fill_value参数，当一个对象没有某个索引项时，这里填充的数据为0。
```

<table>
    <tr>
        <th>方法名称</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>add</td>
        <td>用于加法（+）的方法</td>
    </tr>
    <tr>
        <td>sub</td>
        <td>用于减法（-）的方法</td>
    </tr>
    <tr>
        <td>div</td>
        <td>用于除法（/）的方法</td>
    </tr>
    <tr>
        <td>mul</td>
        <td>用于乘法（*）的方法</td>
    </tr>
</table>

- 两家幼儿园DataFrame和Series 数据的合并
```python
from pandas import DataFrame,Series
kindergarten1 = {"小朋友数目":[32,20],"小朋友睡床":[40,30],"上课教室":[3,2]}
kindergarten2 = {"小朋友数目":16,"小朋友睡床":19,"上课教室":2}
kindergarten_dataframe1 = DataFrame(kindergarten1)
kindergarten_series1 = Series(kindergarten2)
kindergarten_all = kindergarten_dataframe1 + kindergarten_series1
print(kindergarten_all)

# Output:
#    小朋友数目  小朋友睡床  上课教室
# 0     48     59     5
# 1     36     49     4

# Explanation:
# 两家幼儿园数据合并的时候，Series数据结构的幼儿园和DataFrame数据结构的幼儿园每条数据都发生了相加，也就是DataFrame数据结构的幼儿园每个班的数据都要加上Series数据结构的幼儿园每个班的数据，这显然是不合理的。
# 但这里探讨的是两种数据的相加是可以运算的，这叫作广播，关于NumPy的知识讲解中提到过这样的内容。
# 默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播。
# 如果你希望匹配行且在列上广播，就可以利用算术方法sub()、add()等，前面提到过的这些算术方法可以通过参数axis来控制轴的方向。
```

对DataFrame和Series进行算术运算时采用广播具有现实意义。

比如一家超市原来定义了一些价格数据，然后随着时间的推移，物价发生了改变，每件商品的价格都在调整，那就可以用这种算术运算的方式去广播修改每件商品的价格。

如果价格方面算术运算的值是不相同的，就可以使用前面提到的loc()方法对数据进行切片或条件的定位，再进行相关的广播操作。

## 数据处理

数据清洗

Pandas的设计目标之一就是让数据处理的任务变得轻松一点儿。

### 判断缺失数据

缺失数据是数据处理中常见的一种情况，NaN可以作为被检测出来的标记。

isnull()方法用来判断数据中是否含有缺失数据。

- 判断描述车的DataFrame数据中是否有缺失数据
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[numpy.nan, 9.80, numpy.nan], "最高报价":[49.80, numpy.nan, 58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_isnull = goods_in.isnull()
print(goods_in_isnull)

# Output:
#       车名   最低报价   最高报价
# 1  False   True  False
# 2  False  False   True
# 3  False   True  False
```

- 对描述车的DataFrame数据根据isnull()的布尔值将缺失数据选取出来
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[numpy.nan, 9.80, numpy.nan], "最高报价":[49.80, 23.10, 58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_isnull = goods_in[goods_in["最低报价"].isnull()]
print(goods_in_isnull)

# Output:
#       车名  最低报价   最高报价
# 1  奥迪Q5L   NaN  49.80
# 3  奔驰GLC   NaN  58.78

# Explanation:
# 代码中用goods_in["最低报价"].isnull()来判断"最低报价"维度数据中的缺失数据，结果是布尔数组
# 用这个布尔数组作为goods_in的参数，就会把“最低报价”为空的那一行数据选出。
```

- DataFrame数据表中缺失数据的处理方法
<table>
    <tr>
        <th>方法名称</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>dropna</td>
        <td>根据各标签的值中是否存在缺失数据对轴标签进行过滤，可通过阈值调节对缺失数据的容忍度</td>
    </tr>
    <tr>
        <td>fillna</td>
        <td>用指定值或插值方法（如ffill或bfill）填充缺失数据</td>
    </tr>
    <tr>
        <td>isnull</td>
        <td>返回一个含有布尔值的对象，这些布尔值表示哪些数据是缺失,该对象的类型与原类型一致</td>
    </tr>
    <tr>
        <td>notnull</td>
        <td>isnull的否定式</td>
    </tr>
</table>

### 删除缺失数据

dropna()返回一个仅含非空数据和索引值的Pandas对应的数据结构，默认丢弃任何含有缺失数据的行

- 对描述车的DataFrame数据dropna()返回仅含非空数据的行
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[numpy.nan, 9.80, numpy.nan], "最高报价":[49.80, 23.10, 58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_nonull = goods_in.dropna()
print(goods_in_nonull)

# Output:
#      车名  最低报价  最高报价
# 2  哈弗H6   9.8  23.1
```

dropna()也提供了一些参数，传入how="all"将只丢弃全为NaN的那些行

- 对描述车的DataFrame数据dropna()删除全为NaN的行
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC",numpy.nan], "最低报价":[numpy.nan,9.80,numpy.nan,numpy.nan], "最高报价":[49.80,23.10,58.78,numpy.nan]}
goods_in = DataFrame(paints, index=[1,2,3,4])
print(goods_in)
print("------------------------------")
goods_in_nonull = goods_in.dropna(how="all")
print(goods_in_nonull)

# Output:
#       车名  最低报价   最高报价
# 1  奥迪Q5L   NaN  49.80
# 2   哈弗H6   9.8  23.10
# 3  奔驰GLC   NaN  58.78
# 4    NaN   NaN    NaN
# ------------------------------
#       车名  最低报价   最高报价
# 1  奥迪Q5L   NaN  49.80
# 2   哈弗H6   9.8  23.10
# 3  奔驰GLC   NaN  58.78
```

如果要删除的是某一列，传入axis=1即可

- 对描述车的DataFrame数据dropna()删除含NaN的列
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[numpy.nan,9.80,numpy.nan], "最高报价":[49.80,23.10,58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_nonull = goods_in.dropna(axis=1)
print(goods_in_nonull)

# Output:
#       车名   最高报价
# 1  奥迪Q5L  49.80
# 2   哈弗H6  23.10
# 3  奔驰GLC  58.78
```

### 填充缺失数据

对缺失数据不是只有删除这一种操作，如果在数据量很少的情况下，再进行删除操作会造成后面机器学习的时候数据预测不准确。

对缺失数据的另外一种操作就是填补那些"空洞"。

- 对描述车的DataFrame数据fillna()用常数填充含NaN的数据列
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[numpy.nan,9.80,numpy.nan], "最高报价":[49.80,23.10,58.78]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_nonull = goods_in.fillna(10)
print(goods_in_nonull)

# Output:
#       车名  最低报价   最高报价
# 1  奥迪Q5L  10.0  49.80
# 2   哈弗H6   9.8  23.10
# 3  奔驰GLC  10.0  58.78
```

- 对描述车的DataFrame数据fillna()用字典填充含NaN的数据列
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[numpy.nan,9.80,numpy.nan], "最高报价":[49.80,23.10,numpy.nan]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_fill = goods_in.fillna({"最低报价":10,"最高报价":20})
print(goods_in_fill)

# Output:
#       车名  最低报价  最高报价
# 1  奥迪Q5L  10.0  49.8
# 2   哈弗H6   9.8  23.1
# 3  奔驰GLC  10.0  20.0
```

- 对描述车的DataFrame数据fillna()用method插值填充NaN数据列
```python
from pandas import DataFrame
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[9.80,numpy.nan,15.42], "最高报价":[49.80,23.10,numpy.nan]}
goods_in = DataFrame(paints, index=[1,2,3])
goods_in_fill = goods_in.fillna(method="ffill")
print(goods_in_fill)

# Output:
#       车名   最低报价  最高报价
# 1  奥迪Q5L   9.80  49.8
# 2   哈弗H6   9.80  23.1
# 3  奔驰GLC  15.42  23.1

# Explanation:
# 填充的数值采用对reindex()有效的插值方法method="ffill"，含义是“前向数据填充”，即用前面的数据进行填充
```

- 对描述车的DataFrame数据fillna()用中位数填充NaN数据列 - median
```python
from pandas import DataFrame,Series
import numpy
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC"], "最低报价":[9.80,numpy.nan,15.42], "最高报价":[49.80,23.10,numpy.nan]}
goods_in = DataFrame(paints,index=[1,2,3])
goods_in_fill = goods_in.fillna({"最低报价": goods_in["最低报价"].median(), "最高报价": goods_in["最高报价"].median()})
print(goods_in_fill)

# Output:
#       车名   最低报价   最高报价
# 1  奥迪Q5L   9.80  49.80
# 2   哈弗H6  12.61  23.10
# 3  奔驰GLC  15.42  36.45
```

### 移除重复数据

- DataFrame描述车数据重复行的检测
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"], "最低报价":[9.80,14.35,15.42,9.80,14.35], "最高报价":[49.80,23.10,60.45,49.80,23.10]}
goods_in = DataFrame(paints)
goods_in_duplicated = goods_in.duplicated()
print(goods_in_duplicated)

# Output:
# 0    False
# 1    False
# 2    False
# 3     True
# 4     True
# dtype: bool
```

drop_duplicates()用于返回一个删除了重复行的DataFrame，也就是实现了删除重复项

- DataFrame描述车数据重复行的删除
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"], "最低报价":[9.80,14.35,15.42,9.80,14.35], "最高报价":[49.80,23.10,60.45,49.80,23.10]}
goods_in = DataFrame(paints)
goods_in_duplicated = goods_in.drop_duplicates()
print(goods_in_duplicated)

# Output:
#       车名   最低报价   最高报价
# 0  奥迪Q5L   9.80  49.80
# 1   哈弗H6  14.35  23.10
# 2  奔驰GLC  15.42  60.45
```

从运行结果上看，drop_duplicates()默认保留的是第一个出现的值组合

若传入keep="last"，则保留最后一个

- DataFrames描述车数据保留最后重复行
```python
from pandas import DataFrame
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"], "最低报价":[9.80,14.35,15.42,9.80,14.35], "最高报价":[49.80,23.10,60.45,49.80,23.10]}
goods_in = DataFrame(paints)
goods_in_duplicated = goods_in.drop_duplicates(["车名","最低报价","最高报价"], keep="last")
print(goods_in_duplicated)

# Output:
#       车名   最低报价   最高报价
# 2  奔驰GLC  15.42  60.45
# 3  奥迪Q5L   9.80  49.80
# 4   哈弗H6  14.35  23.10

# Explanation:
# 从运行结果上看，索引数字为0和1的重复项是最先出现的，被drop_duplicates()方法删除了，而后面的索引数字为3和4的数据被留了下来。
```

### 替换数据

- DataFrame描述车数据使用replace()替换数据
```python
from pandas import DataFrame
import numpy as np
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"], "最低报价":[9.80,14.35,15.42,9.80,np.nan], "最高报价":[49.80,23.45,np.nan,49.80,23.10]}
goods_in = DataFrame(paints)
goods_in_replace = goods_in.replace(np.nan,20.50)
print(goods_in_replace)

# Output:
#       车名   最低报价   最高报价
# 0  奥迪Q5L   9.80  49.80
# 1   哈弗H6  14.35  23.45
# 2  奔驰GLC  15.42  20.50
# 3  奥迪Q5L   9.80  49.80
# 4   哈弗H6  20.50  23.10
```

- DataFrame描述车数据使用replace()字典参数替换数据
```python
from pandas import DataFrame
import numpy as np
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"], "最低报价":[9.80,14.35,15.42,0,np.nan], "最高报价":[0,23.45,np.nan,49.80,23.10]}
goods_in = DataFrame(paints)
goods_in_replace = goods_in.replace({np.nan:20.50, 0:25.47})
print(goods_in_replace)

# Output:
#       车名   最低报价   最高报价
# 0  奥迪Q5L   9.80  25.47
# 1   哈弗H6  14.35  23.45
# 2  奔驰GLC  15.42  20.50
# 3  奥迪Q5L  25.47  49.80
# 4   哈弗H6  20.50  23.10
```

### 排列和随机采样

利用permutation()方法可以轻松实现对Series或DataFrame的列的提取工作。

通过对需要排列的轴的长度调用permutation()，可产生一个具有新顺序的整数数组。

- DataFrame描述车数据使用permutation()提取列
```python
from pandas import DataFrame
import numpy as np
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"], "最低报价":[9.80,14.35,15.42,0,12.35], "最高报价":[0,23.45,26.47,49.80,23.10]}
goods_in = DataFrame(paints, index=[0,1,2,3,4])
goods_in_permutation = np.random.permutation(goods_in)
print(goods_in_permutation)

# Output:
# [['奥迪Q5L' 0.0 49.8]
#  ['奔驰GLC' 15.42 26.47]
#  ['哈弗H6' 14.35 23.45]
#  ['哈弗H6' 12.35 23.1]
#  ['奥迪Q5L' 9.8 0.0]]

# Explanation:
# 从运行结果上看，其实这个二维数组的顺序不是固定的，每次运行都有不同的顺序。
# 这也是permutation()随机提取的原因。但每一行的数据与维度是一一对应的关系。
# 利用这样的随机特性结合take()方法可以进行随机采样。
```

在机器学习阶段，需要在对数据进行研究的基础上进行算法模型的预设。

在对数据进行研究时，如果数据量比较大就需要进行采样。

- DataFrame描述车数据使用take()和permutation()进行数据采样
```python
from pandas import DataFrame
import numpy as np
paints = {"车名":["奥迪Q5L","哈弗H6","奔驰GLC","奥迪Q5L","哈弗H6"],"最低报价":[9.80,14.35,15.42,0,12.35],"最高报价":[0,23.45,26.47,49.80,23.10]}
goods_in = DataFrame(paints, index=[0,1,2,3,4])
goods_in_permutation = goods_in.take(np.random.permutation(len(goods_in)))
print(goods_in_permutation)

# Output:
#       车名   最低报价   最高报价
# 2  奔驰GLC  15.42  26.47
# 0  奥迪Q5L   9.80   0.00
# 3  奥迪Q5L   0.00  49.80
# 1   哈弗H6  14.35  23.45
# 4   哈弗H6  12.35  23.10

# Explanation:
# 从运行结果上看，是把DataFrame描述车的数据全部随机提取出来，而且每次的运行顺序也是不一样的。
# 如果要提取其中的某几条，可以通过np.random.permutation(3)语句，这样只是从全部数据中提取出3条数据。
```