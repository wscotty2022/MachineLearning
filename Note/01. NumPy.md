# 数组计算 - NumPy

## 简介

1. Numpy，全称为Numerical Python，是高性能的**科学计算**和**数据分析**的基础包。
2. 具有ndarray的数据类型（具有**矢量算术运算vectorization**和**复杂广播能力broadcasting**的快速且节省空间的数组）。
3. **无须循环遍历**数组中的每个元素，就可以对整组数据进行快速运算。
4. 提供支持快速运算的**标准数学方法**。
5. 提供了**读写磁盘数据**的工具。
6. NumPy数组的计算将有助于**高效地使用Pandas**。
7. NumPy是用C/C++来编写的，所以提供了CAPI，因此很容易将数据传递到由**更低级语言**编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。

## NumPy模块的数组对象(Array objects) - ndarray

### 创建数组对象

- NumPy的数组对象是ndarray，是一种快速且灵活的大数据集容器，可用于存放同类型元素的多维数组

```python
numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndim = 0)
# 1. object: 数组或嵌套的数列如list (Mandatory)【array_like】
# 2. dtype : 数组元素的类型 (Optional)
# 3. copy  ：对象是否需要复制 (Optional)【bool】
# 4. order : 创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）(Optional)
# 5. subok : 如果为True，则子类将被传递，否则返回的数组将被强制为基类数组（默认）。(Optional)【bool】
# 6. ndim  : 指定结果数组应具有的最小维数(Optional) 【int】
```

- 采用array()方法将列表转化成数组
```python
import numpy as np
arr = np.array([10,20,30,40,50])
print(arr)

# Output:
# [10 20 30 40 50]
```

- 在array()方法中添加维度参数ndim
```python
import numpy as np
arr = np.array([10,20,30,40,50], ndim=2)
print(arr)

# Output:
# [[10 20 30 40 50]]
# 传入的是一维列表的参数，输出变成了二维数组。
```

- 在array()方法中添加类型说明参数dtype
```python
import numpy as np
arr=np.array([10,20,30,40,50],dtype=complex)
print(arr)

# Output:
# [[10. +0.j 20. +0.j 30. +0.j 40. +0.j 50. +0.j]]
```

- 输出NumPy数组的**dtype**和**shape**值
```python
import numpy as np
lists1=[[101,202,303],[404,505,606]]
arr1=np.array(lists1)
print("数组arr1的数据类型是：")
print(arr1.dtype)
print("数组arr1的数组形状是：")
print(arr1.shape)

# Output:
# 数组arr1的数据类型是：
# int32
# 数组arr1的数组形状是：
# (2, 3)
```

- NumPy模块创建**全0**数组
```python
import numpy as np
arr1 = np.zeroes((3,4))
print(arr1)

# Output:
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]
```

- NumPy模块创建**全1**数组
```python
import numpy as np
arr1 = np.ones((3,4))
print(arr1)

# Output:
# [[1. 1. 1. 1.]
#  [1. 1. 1. 1.]
#  [1. 1. 1. 1.]]
```

- NumPy模块创建**对角线**上数值为1的数组（一）
```python
import numpy as np
arr1 = np.eye(4)
print(arr1)

# Output:
# [[1. 0. 0. 0.]
#  [0. 1. 0. 0.]
#  [0. 0. 1. 0.]
#  [0. 0. 0. 1.]]
```

- NumPy模块创建**对角线**上数值为1的数组（二）
```python
import numpy as np
arr1 = np.identity(3)
print(arr1)

# Output:
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]
```

- NumPy模块创建**无具体值** / **无意义**的数组的代码运行结果
```python
import numpy as np
arr1 = np.empty((3,4))
print(arr1)

# Output:
# [[4.45057637e-308 1.78021527e-306 8.45549797e-307 1.37962049e-306]
#  [1.11260619e-306 1.78010255e-306 9.79054228e-307 4.45057637e-308]
#  [8.45596650e-307 9.34602321e-307 4.94065646e-322 0.00000000e+000]]
```

### 数组对象类型的说明

- 数值型dtype的命名方式：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。

> 1. int8, uint8, int16, uint16, int32, uint32, int64, uint64
> 2. float16, float32, float64, float128
> 3. complex64, complex128, complex256
> 4. bool
> 5. Object
> 6. String_
> 7. Unicode_

- NumPy模块实现dtype数据类型的转换
```python
import numpy as np
arr1 = np.array([12.5,136.7,24.6,35.5,109.8])
int_arr1 = arr1.astype(int)
print(int_arr1.dtype)
str_arr1 = arr1.astype(str)
print(str_arr1.dtype)

# Output:
# int32
# <U32
```

> 注意：使用astype()进行数据类型转换的时候，无论如何都会创建出一个新的数组，也就是原始数组的一份副本。

### 随机数生成数组

NumPy的**random模块**对Python内置的random模块进行了补充，增加了一些用于**高效生成多种概率分布的样本值**的方法。

例如，你可以用normal()来得到一个标准高斯分布Gaussian distribution / Normal Distribution（又称正态分布）的4×4样本数组。

```python
import numpy as np
samples = np.random.normal(size=(4,4))
print(samples)

# Output:
#[[ 0.72200786  0.26453997 -0.3351595   0.54814133]
# [ 0.86406227  1.23322194 -1.41487959  1.1713989 ]
# [ 0.64198915 -1.4730376   0.4680829   0.99875542]
# [ 0.83425153  0.59974125 -0.92092395 -0.12971962]]

# random 是一个模块/module
```

而Python内置的random模块则一次只能生成一个样本值。

> 如果需要产生**大量**的样本值，使用NumPy的random模块执行时间**快了不止一个数量级**。

- Python内置的random模块生成大量样本值的执行时间测试
```python
from random import normalvariate
import time
n = 10000000
start = time.time()
samples = [normalvariate(0,1) for _ in range(n)]
end = time.time()
print(end-start)

# Output:
# 22.30867314338684
```

- NumPy模块生成大量样本值的执行时间测试
```python
import numpy as np
import time
n = 10000000
start = time.time()
samples = np.random.normal(size=n)
end = time.time()
print(end-start)

# Output:
# 0.21704864501953125
```

> 其他一次性生成大量样本值的方法
> 1. **seed**          - 确定随机数生成器的种子
> 2. **permutation**   - 返回一个序列的随机排列或返回一个随机排列的范围
> 3. **shuffle**       - 对一个序列就地随机排列
> 4. **rand**          - 产生均匀分布的样本值
> 5. **randint**       - 从给定的上下限范围内随机选取整数
> 6. **randn**         - 产生高斯分布（平均值为0，标准差为1)的样本值，类似于MATLAB接口
> 7. **binomial**      - 产生二项分布的样本值
> 8. **normal**        - 产生高斯分布的样本值
> 9. **beta**          - 产生beta分布的样本值
> 10. **chisquare**    - 产生卡方分布的样本值
> 11. **gamma**        - 产生gamma分布的样本值
> 12. **uniform**      - 产生在[0,1)中均匀分布的样本值

## 广播 Broadcasting

广播（broadcast）指的是不同形状的数组之间算术运算的执行方式。

大小相等(size)的数组之间的任何算术运算都会被应用到元素级。

- NumPy模块实现大小相等数组的算术运算（乘法/减法）
```python
import numpy as np
arr1 = np.array([[10,20,30],[7,8,9]])
multi_arr = arr1 * arr1
sub_arr = arr1 - arr1
print("大小相等的数组实现乘法")
print(multi_arr)
print("大小相等的数组实现减法")
print(sub_arr)

# Output:
# 大小相等的数组实现乘法
# [[100 400 900]
#  [ 49  64  81]]
# 大小相等的数组实现减法
# [[0 0 0]
#  [0 0 0]]
```

数组还可以和某个值进行算术运算，这个值也称作**标量 Scalar**。

- NumPy模块实现数组和标量的运算（乘法/除法）
```python
import numpy as np
arr1 = np.array([[10,20,30],[7,8,9]])
divide_arr = 100 / arr1
multi_arr = arr1 * 0.5
print("数组与标量值的除法运算")
print(divide_arr)
print("数组与标量值的乘法运算")
print(multi_arr)

# Output:
# 数组与标量值的除法运算
# [[10.          5.          3.33333333]
#  [14.28571429 12.5        11.11111111]]
# 数组与标量值的乘法运算
# [[ 5.  10.  15. ]
#  [ 3.5  4.   4.5]]
```

> 在这个乘法或除法的具体运算中，标量值100或0.5被传播到了其他所有的元素上，这种技术就叫作广播，标量值和数组之间的合并运算就是最简单的广播。

### 数组广播的原则

距平 Anomaly - 一组数据中的某一个数值与平均数之间的差

- NumPy模块计算某段时间内的周气温距平
```python
import numpy as np
weathers=np.array([[20,21,22,18,19,21,22],[18,21,23,19,18,21,13],[18,19,22,21,21,17,16],[15,18,20,19,21,17,18]])
print(weathers.mean(0))
anomaly = weathers - weathers.mean(0)
print(anomaly)
print(anomaly.mean(0))

# Output:
# [17.75 19.75 21.75 19.25 19.75 19.   17.25]
# [[ 2.25  1.25  0.25 -1.25 -0.75  2.    4.75]
#  [ 0.25  1.25  1.25 -0.25 -1.75  2.   -4.25]
#  [ 0.25 -0.75  0.25  1.75  1.25 -2.   -1.25]
#  [-2.75 -1.75 -1.75 -0.25  1.25 -2.    0.75]]
# [0. 0. 0. 0. 0. 0. 0.]

# 17.75 = (20+18+18+15)/4  ==> mean (row-wise - 可以理解为row和row之间的比较)
# 2.25 = 20-17.75 ==> anomaly
# anomaly.mean(0) ==> x-axis (row-wise)
```

- NumPy模块计算某段时间星期中每一天气温的距平
```python
import numpy as np
weathers=np.array([[20,21,22,18,19,21,22],[18,21,23,19,18,21,13],[18,19,22,21,21,17,16],[15,18,20,19,21,17,18]])
print(weathers.mean(1).reshape((4,1)))
meaned = weathers - weathers.mean(1).reshape((4,1))
print(meaned)
print(meaned.mean(1))

# Output:
# [[20.42857143]
#  [19.        ]
#  [19.14285714]
#  [18.28571429]]
# [[-0.42857143  0.57142857  1.57142857 -2.42857143 -1.42857143  0.57142857
#    1.57142857]
#  [-1.          2.          4.          0.         -1.          2.
#   -6.        ]
#  [-1.14285714 -0.14285714  2.85714286  1.85714286  1.85714286 -2.14285714
#   -3.14285714]
#  [-3.28571429 -0.28571429  1.71428571  0.71428571  2.71428571 -1.28571429
#   -0.28571429]]
# [1.52259158e-15 0.00000000e+00 5.07530526e-16 1.01506105e-15]

# 20.42857143 = (20+21+22+18+19+21+22)/7  ==> mean (column-wise - 可以理解为column和column之间的比较)
# -0.42857143 = 20-20.42857143 ==> anomaly
# anomaly.mean(0) ==> x-axis (column-wise - 可以理解为column和column之间的比较)
```

> 二维数组的广播发生在行上或者是列上，不管是行上还是列上，其中**必有一个维度为1**。

- NumPy模块利用广播设置特殊数组的元素值
```python
import numpy as np
arr = np.ones((4,6))
arr = arr * 7
print(arr)

# Output: 
# [[7. 7. 7. 7. 7. 7.]
#  [7. 7. 7. 7. 7. 7.]
#  [7. 7. 7. 7. 7. 7.]
#  [7. 7. 7. 7. 7. 7.]]
```

- NumPy模块利用**索引位置**设置特殊数组的元素值
```python
import numpy as np
arr = np.ones((4,6))
arr[:] = 7
print(arr)

# Output:
# [[7. 7. 7. 7. 7. 7.]
#  [7. 7. 7. 7. 7. 7.]
#  [7. 7. 7. 7. 7. 7.]
#  [7. 7. 7. 7. 7. 7.]]
```

## NumPy模块中数组的操作

### 切片的索引

- NumPy模块利用索引访问数组元素的值
```python
import numpy as np
arr = np.array([3.1, 3.14, 3.141, 3.1415, 3.14159, 3.141592, 3.1415926])
print(arr[4])
print("------------------")
print(arr[3:6])
print("------------------")
arr[3:6] = 3.14159265358
print(arr)

# Output:
# 3.14159
# ------------------
# [3.1415   3.14159  3.141592]
# ------------------
# [3.1        3.14       3.141      3.14159265 3.14159265 3.14159265
#  3.1415926 ]
```

> 注意：数组切片是原始数组的视图，视图上的任何修改都会直接反映到原数组上。这也是由于NumPy的设计目的是处理大数据。

### 布尔型索引

按照条件来提取合适的数据

- NumPy模块**布尔型索**引肯定条件提取数组中的数据
```python
import numpy as np
names = np.array(["业务员","业务员","经理","主管","业务员","主管"])
salary = np.array([2520.00, 3600.00, 2745.00, 4200.00, 3805.00, 3947.00])
print(salary[names=="业务员"])

# Output:
# [2520. 3600. 3805.]
```

使用不等于符号（!=），也可以通过浪纹线（~）对条件进行否定。

- NumPy模块布尔型索引**否定条件**提取数组中的数据
```python
import numpy as np
names = np.array(["业务员","业务员","经理","主管","业务员","主管"])
salary = np.array([2520.00, 3600.00, 2745.00, 4200.00, 3805.00, 3947.00])
print(salary[names!="业务员"])
print("----------------------------")
print(salary[~(names=="业务员")])

# Output:
# [2745. 4200. 3947.]
# ----------------------------
# [2745. 4200. 3947.]
```

- NumPy模块布尔型索引**多条件**提取数组中的数据
```python
import numpy as np
names = np.array(["业务员","业务员","经理","主管","业务员","主管"])
salary = np.array([2520.00, 3600.00, 2745.00, 4200.00, 3805.00, 3947.00])
print(salary[(names == "经理") | (names == "主管")])
print("-------------------")
print(salary[(names == "主管") & (salary > 4000)])

# Output:
# [2745. 4200. 3947.]
# -------------------
# [4200.]
```

### 数组的转置和轴变换

这个操作借鉴了线性代数中矩阵的转置操作，将行与列对调，即第一行变成第一列或第一列变成第一行的操作便是转置操作。

数组的转置使用transpose()方法，它返回的是**原数据的视图**，不会进行复制操作。

- NumPy模块transpose()方法实现数组转置
```python
import numpy as np
arr=np.array([[1,1,1,1,1],[2,2,2,2,2],[3,3,3,3,3],[4,4,4,4,4],[5,5,5,5,5]])
arr_trans=arr.transpose()
print(arr_trans)

# Output:
# [[1 2 3 4 5]
#  [1 2 3 4 5]
#  [1 2 3 4 5]
#  [1 2 3 4 5]
#  [1 2 3 4 5]]
```

> transpose()方法也可以用一个特殊的Ｔ属性来代替

```python
import numpy as np
arr=np.array([[1,1,1,1,1],[2,2,2,2,2],[3,3,3,3,3],[4,4,4,4,4],[5,5,5,5,5]])
arr_trans=arr.T
print(arr_trans)

# Output:
# [[1 2 3 4 5]
#  [1 2 3 4 5]
#  [1 2 3 4 5]
#  [1 2 3 4 5]
#  [1 2 3 4 5]]
```

在NumPy中，dot用作数组之间的点乘运算。常常被用来计算 *y=ax1+bx2+cx3+dx4* 这种形式的式子。

- NumPy模块实现**点乘结果**示例
```python
import numpy as np
arr=np.random.randn(4,)
print(arr)
result = np.dot(arr.T,arr)
print(result)

# Output:
# [0.11490031 0.29711086 0.58063688 1.15301399]
# 1.7680573927840668

# Explanation:
# 1.7680573927840668 = (0.11490031*0.11490031) + (0.29711086*0.29711086) + (0.58063688*0.58063688) + (1.15301399*1.15301399)
# np.random.randn(4,) 和 np.random.randn(4) 都会返回一维数组
# 可以将数组中的数据看成不同的x1,x2,x3,x4，然后将这个数组转置，就变成了a,b,c,d的随机数据,同时行也变成了列；再按照点乘公式点乘，就得到一个结果数据result。
# result满足的条件就是ax1+bx2+cx3+dx4，
```

- NumPy模块transpose()实现三维数组的**x轴**和**y轴**交换
```python
import numpy as np
arr = np.arange(16).reshape(2,2,4)
trans_arr = arr.transpose(1,0,2)
print(trans_arr)

# Output:
# [[[ 0  1  2  3]
#   [ 8  9 10 11]]
# 
#  [[ 4  5  6  7]
#   [12 13 14 15]]]

# Explanation:
# Size of X and Y are unchanged because both are the same
# 1. Prepare 2 X
# 2. Put the first Y in first X to first X [0 1 2 3]
# 3. Put the second Y in first X to second X [4 5 6 7]
# 4. Put the first Y in second X to first X [8 9 10 11]
# 5. Put the second Y in second X to second X [12 13 14 15]
```

- NumPy模块transpose()实现三维数组的**x轴**和**z轴**交换
```python
import numpy as np
arr = np.arange(16).reshape(2,2,4)
trans_arr = arr.transpose(2,1,0)
print(trans_arr)

# Output:
# [[[ 0  8]
#   [ 4 12]]
# 
#  [[ 1  9]
#   [ 5 13]]
# 
#  [[ 2 10]
#   [ 6 14]]
# 
#  [[ 3 11]
#   [ 7 15]]]

# Explanation:
# Size of x = 4, size of z = 2
# 1. Put the first Z (0) to the first X(top), second Z to the second X, third Z to the third X and fourth Z to the fourth X.
```

- NumPy模块transpose()实现三维数组的**y轴**和**z轴**交换
```python
import numpy as np
arr=np.arange(16).reshape(2,2,4)
trans_arr = arr.transpose(0,2,1)
print(trans_arr)


# [[[ 0  1  2  3]
#  [[ 4  5  6  7]

#   [ 8  9 10 11]]
#   [12 13 14 15]]]


# Output:
# [[[ 0  4]
#   [ 1  5]
#   [ 2  6]
#   [ 3  7]]
# 
#  [[ 8  12]
#   [ 9  13]]
#   [ 10  14]]
#   [ 11  15]]]

# Explanation:
# Size of Y = 4, size of Z = 2
```